#!/usr/bin/env node

/**
 * 索克生活APP - 性能优化脚本
 * 优化应用性能、内存使用和用户体验
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class PerformanceOptimizer {
  constructor() {
    this.srcDir = path.join(__dirname, '../src');
    this.optimizations = [];
    this.errors = [];
  }

  /**
   * 运行性能优化
   */
  async optimize() {
    console.log('⚡ 开始索克生活APP性能优化...\n');

    try {
      // 1. 组件性能优化
      await this.optimizeComponents();
      
      // 2. 图片资源优化
      await this.optimizeImages();
      
      // 3. 代码分割优化
      await this.optimizeCodeSplitting();
      
      // 4. 内存优化
      await this.optimizeMemory();
      
      // 5. 网络请求优化
      await this.optimizeNetworking();
      
      // 6. 存储优化
      await this.optimizeStorage();
      
      // 7. 生成性能报告
      this.generateReport();
      
    } catch (error) {
      console.error('❌ 性能优化过程中出现错误:', error.message);
      process.exit(1);
    }
  }

  /**
   * 组件性能优化
   */
  async optimizeComponents() {
    console.log('🔧 优化组件性能...');
    
    const componentFiles = this.getComponentFiles();
    let optimizedCount = 0;
    
    for (const file of componentFiles) {
      try {
        const content = fs.readFileSync(file, 'utf8');
        const optimizedContent = this.optimizeComponentPerformance(content);
        
        if (content !== optimizedContent) {
          fs.writeFileSync(file, optimizedContent);
          optimizedCount++;
          this.optimizations.push(`组件优化: ${path.relative(this.srcDir, file)}`);
        }
      } catch (error) {
        this.errors.push(`组件优化失败: ${file} - ${error.message}`);
      }
    }
    
    console.log(`✅ 优化了 ${optimizedCount} 个组件`);
  }

  /**
   * 图片资源优化
   */
  async optimizeImages() {
    console.log('🖼️  优化图片资源...');
    
    const imageDir = path.join(this.srcDir, 'assets/images');
    if (!fs.existsSync(imageDir)) {
      console.log('⚠️  图片目录不存在，跳过图片优化');
      return;
    }
    
    // 创建图片优化配置
    const optimizationConfig = {
      webp: true,
      quality: 80,
      progressive: true,
      sizes: [1, 2, 3] // 1x, 2x, 3x
    };
    
    await this.createImageOptimizationScript(optimizationConfig);
    console.log('✅ 图片优化配置已创建');
  }

  /**
   * 创建图片优化脚本
   */
  async createImageOptimizationScript(config) {
    const scriptTemplate = `/**
 * 图片优化配置
 * 索克生活APP - 性能优化
 */

export const imageOptimizationConfig = ${JSON.stringify(config, null, 2)};

// 图片优化工具
export class ImageOptimizer {
  static optimizeImage(imagePath: string, options = {}) {
    // 图片优化逻辑
    const defaultOptions = {
      quality: ${config.quality},
      format: 'webp',
      progressive: ${config.progressive}
    };
    
    return { ...defaultOptions, ...options };
  }
  
  static generateResponsiveImages(imagePath: string) {
    const sizes = ${JSON.stringify(config.sizes)};
    return sizes.map(size => ({
      size: \`\${size}x\`,
      path: imagePath.replace(/\\.([^.]+)$/, \`@\${size}x.$1\`)
    }));
  }
}
`;

    const configPath = path.join(this.srcDir, 'utils/imageOptimization.ts');
    fs.writeFileSync(configPath, scriptTemplate);
    this.optimizations.push('创建图片优化配置');
  }

  /**
   * 代码分割优化
   */
  async optimizeCodeSplitting() {
    console.log('📦 优化代码分割...');
    
    // 创建懒加载组件
    await this.createLazyComponents();
    
    // 优化路由分割
    await this.optimizeRouting();
    
    console.log('✅ 代码分割优化完成');
  }

  /**
   * 内存优化
   */
  async optimizeMemory() {
    console.log('🧠 优化内存使用...');
    
    // 创建内存监控工具
    await this.createMemoryMonitor();
    
    // 优化大型数据处理
    await this.optimizeDataProcessing();
    
    console.log('✅ 内存优化完成');
  }

  /**
   * 网络请求优化
   */
  async optimizeNetworking() {
    console.log('🌐 优化网络请求...');
    
    // 创建请求缓存策略
    await this.createRequestCache();
    
    // 优化API调用
    await this.optimizeApiCalls();
    
    console.log('✅ 网络请求优化完成');
  }

  /**
   * 存储优化
   */
  async optimizeStorage() {
    console.log('💾 优化存储策略...');
    
    // 创建存储管理器
    await this.createStorageManager();
    
    console.log('✅ 存储优化完成');
  }

  /**
   * 优化组件性能
   */
  optimizeComponentPerformance(content) {
    let optimized = content;
    
    // 1. 添加React.memo
    if (optimized.includes('export default function') && !optimized.includes('React.memo')) {
      optimized = optimized.replace(
        /export default function (\w+)/,
        'const $1 = React.memo(function $1'
      );
      optimized += '\n\nexport default $1;';
    }
    
    // 2. 优化useCallback
    const callbackPattern = /const\s+(\w+)\s*=\s*\([^)]*\)\s*=>\s*{/g;
    optimized = optimized.replace(callbackPattern, (match, funcName) => {
      return `const ${funcName} = useCallback(${match.substring(match.indexOf('=') + 1)}, []);`;
    });
    
    // 3. 添加useMemo优化
    const expensiveComputationPattern = /const\s+(\w+)\s*=\s*[^;]+\.map\(|\.filter\(|\.reduce\(/g;
    if (expensiveComputationPattern.test(optimized)) {
      optimized = optimized.replace(
        /const\s+(\w+)\s*=\s*([^;]+);/g,
        'const $1 = useMemo(() => $2, []);'
      );
    }
    
    return optimized;
  }

  /**
   * 创建懒加载组件
   */
  async createLazyComponents() {
    const lazyComponentTemplate = `/**
 * 懒加载组件工厂
 * 索克生活APP - 性能优化
 */

import React, { Suspense, lazy } from 'react';
import { ActivityIndicator, View } from 'react-native';

// 加载指示器组件
const LoadingIndicator = () => (
  <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
    <ActivityIndicator size="large" color="#007AFF" />
  </View>
);

// 懒加载组件工厂
export const createLazyComponent = (importFunc: () => Promise<any>) => {
  const LazyComponent = lazy(importFunc);
  
  return (props: any) => (
    <Suspense fallback={<LoadingIndicator />}>
      <LazyComponent {...props} />
    </Suspense>
  );
};

// 预定义的懒加载组件
export const LazyScreens = {
  // 诊断相关屏幕
  DiagnosisScreen: createLazyComponent(() => import('../screens/diagnosis/DiagnosisScreen')),
  FiveDiagnosisScreen: createLazyComponent(() => import('../screens/diagnosis/FiveDiagnosisScreen')),
  
  // 智能体相关屏幕
  XiaoaiScreen: createLazyComponent(() => import('../screens/agents/XiaoaiScreen')),
  XiaokeScreen: createLazyComponent(() => import('../screens/agents/XiaokeScreen')),
  LaokeScreen: createLazyComponent(() => import('../screens/agents/LaokeScreen')),
  SoerScreen: createLazyComponent(() => import('../screens/agents/SoerScreen')),
  
  // 生活相关屏幕
  LifeScreen: createLazyComponent(() => import('../screens/life/LifeScreen')),
  ExploreScreen: createLazyComponent(() => import('../screens/explore/ExploreScreen')),
};
`;

    const lazyComponentPath = path.join(this.srcDir, 'components/common/LazyComponents.tsx');
    fs.writeFileSync(lazyComponentPath, lazyComponentTemplate);
    this.optimizations.push('创建懒加载组件工厂');
  }

  /**
   * 创建内存监控工具
   */
  async createMemoryMonitor() {
    const memoryMonitorTemplate = `/**
 * 内存监控工具
 * 索克生活APP - 性能优化
 */

import { useEffect, useRef } from 'react';

interface MemoryInfo {
  usedJSHeapSize: number;
  totalJSHeapSize: number;
  jsHeapSizeLimit: number;
}

class MemoryMonitor {
  private static instance: MemoryMonitor;
  private listeners: ((info: MemoryInfo) => void)[] = [];
  private intervalId: NodeJS.Timeout | null = null;

  static getInstance(): MemoryMonitor {
    if (!MemoryMonitor.instance) {
      MemoryMonitor.instance = new MemoryMonitor();
    }
    return MemoryMonitor.instance;
  }

  startMonitoring(interval: number = 5000) {
    if (this.intervalId) return;

    this.intervalId = setInterval(() => {
      const memoryInfo = this.getMemoryInfo();
      if (memoryInfo) {
        this.notifyListeners(memoryInfo);
        this.checkMemoryThreshold(memoryInfo);
      }
    }, interval);
  }

  stopMonitoring() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }

  addListener(callback: (info: MemoryInfo) => void) {
    this.listeners.push(callback);
  }

  removeListener(callback: (info: MemoryInfo) => void) {
    this.listeners = this.listeners.filter(listener => listener !== callback);
  }

  private getMemoryInfo(): MemoryInfo | null {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      return {
        usedJSHeapSize: memory.usedJSHeapSize,
        totalJSHeapSize: memory.totalJSHeapSize,
        jsHeapSizeLimit: memory.jsHeapSizeLimit
      };
    }
    return null;
  }

  private notifyListeners(info: MemoryInfo) {
    this.listeners.forEach(listener => listener(info));
  }

  private checkMemoryThreshold(info: MemoryInfo) {
    const usagePercentage = (info.usedJSHeapSize / info.jsHeapSizeLimit) * 100;
    
    if (usagePercentage > 80) {
      console.warn('内存使用率过高:', usagePercentage.toFixed(2) + '%');
      // 触发垃圾回收建议
      this.suggestGarbageCollection();
    }
  }

  private suggestGarbageCollection() {
    if ('gc' in global) {
      (global as any).gc();
    }
  }
}

// React Hook for memory monitoring
export const useMemoryMonitor = (enabled: boolean = true) => {
  const memoryInfoRef = useRef<MemoryInfo | null>(null);

  useEffect(() => {
    if (!enabled) return;

    const monitor = MemoryMonitor.getInstance();
    
    const handleMemoryUpdate = (info: MemoryInfo) => {
      memoryInfoRef.current = info;
    };

    monitor.addListener(handleMemoryUpdate);
    monitor.startMonitoring();

    return () => {
      monitor.removeListener(handleMemoryUpdate);
      monitor.stopMonitoring();
    };
  }, [enabled]);

  return memoryInfoRef.current;
};

export default MemoryMonitor;
`;

    const memoryMonitorPath = path.join(this.srcDir, 'utils/MemoryMonitor.ts');
    fs.writeFileSync(memoryMonitorPath, memoryMonitorTemplate);
    this.optimizations.push('创建内存监控工具');
  }

  /**
   * 获取组件文件
   */
  getComponentFiles() {
    const files = [];
    
    function traverse(dir) {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory() && !item.startsWith('.')) {
          traverse(fullPath);
        } else if ((item.endsWith('.tsx') || item.endsWith('.ts')) && 
                   (fullPath.includes('components/') || fullPath.includes('screens/'))) {
          files.push(fullPath);
        }
      }
    }
    
    traverse(this.srcDir);
    return files;
  }

  /**
   * 优化路由分割
   */
  async optimizeRouting() {
    const routeOptimizationTemplate = `/**
 * 路由优化配置
 * 索克生活APP - 性能优化
 */

import { createLazyComponent } from '../components/common/LazyComponents';

// 路由懒加载配置
export const lazyRoutes = {
  // 主要屏幕
  Home: createLazyComponent(() => import('../screens/main/HomeScreen')),
  Profile: createLazyComponent(() => import('../screens/profile/ProfileScreen')),
  
  // 认证屏幕
  Login: createLazyComponent(() => import('../screens/auth/LoginScreen')),
  Register: createLazyComponent(() => import('../screens/auth/RegisterScreen')),
  
  // 功能屏幕
  Diagnosis: createLazyComponent(() => import('../screens/diagnosis/FiveDiagnosisScreen')),
  Life: createLazyComponent(() => import('../screens/life/LifeScreen')),
  Explore: createLazyComponent(() => import('../screens/explore/ExploreScreen')),
  Suoke: createLazyComponent(() => import('../screens/suoke/SuokeScreen')),
};

// 路由预加载策略
export const preloadRoutes = ['Home', 'Profile'];
`;

    const routePath = path.join(this.srcDir, 'navigation/LazyRoutes.tsx');
    fs.writeFileSync(routePath, routeOptimizationTemplate);
    this.optimizations.push('创建路由懒加载配置');
  }

  /**
   * 优化大型数据处理
   */
  async optimizeDataProcessing() {
    const dataProcessingTemplate = `/**
 * 数据处理优化工具
 * 索克生活APP - 性能优化
 */

// 分批处理大型数据
export class DataProcessor {
  static async processBatch<T>(
    data: T[],
    processor: (item: T) => Promise<any>,
    batchSize: number = 100
  ): Promise<any[]> {
    const results = [];
    
    for (let i = 0; i < data.length; i += batchSize) {
      const batch = data.slice(i, i + batchSize);
      const batchResults = await Promise.all(
        batch.map(item => processor(item))
      );
      results.push(...batchResults);
      
      // 让出主线程
      await new Promise(resolve => setTimeout(resolve, 0));
    }
    
    return results;
  }
  
  static debounce<T extends (...args: any[]) => any>(
    func: T,
    delay: number
  ): (...args: Parameters<T>) => void {
    let timeoutId: NodeJS.Timeout;
    
    return (...args: Parameters<T>) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func(...args), delay);
    };
  }
  
  static throttle<T extends (...args: any[]) => any>(
    func: T,
    limit: number
  ): (...args: Parameters<T>) => void {
    let inThrottle: boolean;
    
    return (...args: Parameters<T>) => {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
}
`;

    const dataPath = path.join(this.srcDir, 'utils/DataProcessor.ts');
    fs.writeFileSync(dataPath, dataProcessingTemplate);
    this.optimizations.push('创建数据处理优化工具');
  }

  /**
   * 创建请求缓存策略
   */
  async createRequestCache() {
    const cacheTemplate = `/**
 * 请求缓存策略
 * 索克生活APP - 性能优化
 */

interface CacheItem<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

export class RequestCache {
  private cache = new Map<string, CacheItem<any>>();
  private maxSize: number = 100;
  
  set<T>(key: string, data: T, ttl: number = 300000): void { // 默认5分钟
    // 清理过期缓存
    this.cleanup();
    
    // 如果缓存已满，删除最旧的项
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }
  
  get<T>(key: string): T | null {
    const item = this.cache.get(key);
    
    if (!item) return null;
    
    // 检查是否过期
    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  has(key: string): boolean {
    return this.get(key) !== null;
  }
  
  delete(key: string): void {
    this.cache.delete(key);
  }
  
  clear(): void {
    this.cache.clear();
  }
  
  private cleanup(): void {
    const now = Date.now();
    
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > item.ttl) {
        this.cache.delete(key);
      }
    }
  }
}

export const requestCache = new RequestCache();
`;

    const cachePath = path.join(this.srcDir, 'utils/RequestCache.ts');
    fs.writeFileSync(cachePath, cacheTemplate);
    this.optimizations.push('创建请求缓存策略');
  }

  /**
   * 优化API调用
   */
  async optimizeApiCalls() {
    const apiOptimizationTemplate = `/**
 * API调用优化
 * 索克生活APP - 性能优化
 */

import { requestCache } from './RequestCache';

export class ApiOptimizer {
  // 请求去重
  private static pendingRequests = new Map<string, Promise<any>>();
  
  static async cachedRequest<T>(
    key: string,
    requestFn: () => Promise<T>,
    ttl?: number
  ): Promise<T> {
    // 检查缓存
    const cached = requestCache.get<T>(key);
    if (cached) {
      return cached;
    }
    
    // 检查是否有相同的请求正在进行
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key);
    }
    
    // 发起新请求
    const promise = requestFn().then(data => {
      requestCache.set(key, data, ttl);
      this.pendingRequests.delete(key);
      return data;
    }).catch(error => {
      this.pendingRequests.delete(key);
      throw error;
    });
    
    this.pendingRequests.set(key, promise);
    return promise;
  }
  
  // 批量请求
  static async batchRequests<T>(
    requests: Array<() => Promise<T>>,
    concurrency: number = 3
  ): Promise<T[]> {
    const results: T[] = [];
    
    for (let i = 0; i < requests.length; i += concurrency) {
      const batch = requests.slice(i, i + concurrency);
      const batchResults = await Promise.all(
        batch.map(request => request())
      );
      results.push(...batchResults);
    }
    
    return results;
  }
}
`;

    const apiPath = path.join(this.srcDir, 'utils/ApiOptimizer.ts');
    fs.writeFileSync(apiPath, apiOptimizationTemplate);
    this.optimizations.push('创建API调用优化工具');
  }

  /**
   * 创建存储管理器
   */
  async createStorageManager() {
    const storageTemplate = `/**
 * 存储管理器
 * 索克生活APP - 性能优化
 */

import AsyncStorage from '@react-native-async-storage/async-storage';

interface StorageItem {
  data: any;
  timestamp: number;
  ttl?: number;
}

export class StorageManager {
  private static instance: StorageManager;
  
  static getInstance(): StorageManager {
    if (!StorageManager.instance) {
      StorageManager.instance = new StorageManager();
    }
    return StorageManager.instance;
  }
  
  async set(key: string, data: any, ttl?: number): Promise<void> {
    const item: StorageItem = {
      data,
      timestamp: Date.now(),
      ttl
    };
    
    await AsyncStorage.setItem(key, JSON.stringify(item));
  }
  
  async get<T>(key: string): Promise<T | null> {
    try {
      const itemStr = await AsyncStorage.getItem(key);
      if (!itemStr) return null;
      
      const item: StorageItem = JSON.parse(itemStr);
      
      // 检查是否过期
      if (item.ttl && Date.now() - item.timestamp > item.ttl) {
        await this.remove(key);
        return null;
      }
      
      return item.data;
    } catch (error) {
      console.error('Storage get error:', error);
      return null;
    }
  }
  
  async remove(key: string): Promise<void> {
    await AsyncStorage.removeItem(key);
  }
  
  async clear(): Promise<void> {
    await AsyncStorage.clear();
  }
  
  async getAllKeys(): Promise<string[]> {
    return AsyncStorage.getAllKeys();
  }
  
  // 清理过期数据
  async cleanup(): Promise<void> {
    const keys = await this.getAllKeys();
    const now = Date.now();
    
    for (const key of keys) {
      try {
        const itemStr = await AsyncStorage.getItem(key);
        if (itemStr) {
          const item: StorageItem = JSON.parse(itemStr);
          if (item.ttl && now - item.timestamp > item.ttl) {
            await this.remove(key);
          }
        }
      } catch (error) {
        // 如果解析失败，删除该项
        await this.remove(key);
      }
    }
  }
}

export const storageManager = StorageManager.getInstance();
`;

    const storagePath = path.join(this.srcDir, 'utils/StorageManager.ts');
    fs.writeFileSync(storagePath, storageTemplate);
    this.optimizations.push('创建存储管理器');
  }

  /**
   * 生成性能报告
   */
  generateReport() {
    console.log('\n📊 性能优化报告');
    console.log('='.repeat(50));
    console.log(`✅ 完成的优化项目: ${this.optimizations.length}`);
    console.log(`❌ 错误数量: ${this.errors.length}`);
    
    if (this.optimizations.length > 0) {
      console.log('\n✅ 优化项目:');
      this.optimizations.forEach(opt => console.log(`  - ${opt}`));
    }
    
    if (this.errors.length > 0) {
      console.log('\n❌ 错误详情:');
      this.errors.forEach(error => console.log(`  - ${error}`));
    }
    
    console.log('\n🎉 性能优化完成！');
    console.log('建议运行以下命令验证结果:');
    console.log('  npm run build');
    console.log('  npm run test:performance');
  }
}

// 运行性能优化
if (require.main === module) {
  const optimizer = new PerformanceOptimizer();
  optimizer.optimize().catch(console.error);
}

module.exports = PerformanceOptimizer; 