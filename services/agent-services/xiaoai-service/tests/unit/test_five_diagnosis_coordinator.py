"""
五诊协调器单元测试
"""

import asyncio
from datetime import datetime, timezone
from unittest.mock import AsyncMock, Mock, patch

import pytest
from xiaoai.core.five_diagnosis_coordinator import (
    DiagnosisResult,
    DiagnosisSession,
    DiagnosisStatus,
    DiagnosisType,
    FiveDiagnosisCoordinator,
    SessionStatus,
)
from xiaoai.utils.exceptions import DiagnosisError, ServiceUnavailableError


class TestFiveDiagnosisCoordinator:
    """五诊协调器测试类"""
    
    @pytest.fixture
    async def coordinator(self):
        """创建协调器实例"""
        coordinator = FiveDiagnosisCoordinator()
        await coordinator.initialize()
        yield coordinator
        await coordinator.close()
    
    @pytest.fixture
    def mock_service_clients(self):
        """模拟服务客户端"""
        with patch('xiaoai.integration.service_clients.ServiceClientManager') as mock_manager:
            mock_clients = {
                'look': AsyncMock(),
                'listen': AsyncMock(),
                'inquiry': AsyncMock(),
                'palpation': AsyncMock(),
                'calculation': AsyncMock()
            }
            
            # 配置模拟客户端返回值
            for service_name, client in mock_clients.items():\n                client.analyze.return_value = {\n                    \"confidence\": 0.8,\n                    \"features\": {f\"{service_name}_feature\": \"test_value\"},\n                    \"analysis\": {f\"{service_name}_analysis\": \"test_analysis\"}\n                }\n            \n            mock_manager.return_value.clients = mock_clients\n            mock_manager.return_value.get_client.side_effect = lambda name: mock_clients.get(name)\n            \n            yield mock_manager\n    \n    @pytest.mark.asyncio\n    async def test_create_diagnosis_session(self, coordinator):\n        \"\"\"测试创建诊断会话\"\"\"\n        user_id = \"test_user_123\"\n        metadata = {\"source\": \"mobile_app\", \"version\": \"1.0.0\"}\n        \n        session = await coordinator.create_diagnosis_session(user_id, metadata)\n        \n        assert session.user_id==user_id\n        assert session.status==SessionStatus.ACTIVE\n        assert session.metadata==metadata\n        assert session.session_id is not None\n        assert len(session.session_id) > 0\n    \n    @pytest.mark.asyncio\n    async def test_start_diagnosis_process(self, coordinator, mock_service_clients):\n        \"\"\"测试启动诊断流程\"\"\"\n        user_id = \"test_user_123\"\n        session_id = \"test_session_123\"\n        \n        diagnosis_data = {\n            DiagnosisType.LOOKING: {\n                \"image_data\": b\"fake_image_data\",\n                \"image_type\": \"tongue\"\n            },\n            DiagnosisType.LISTENING: {\n                \"audio_data\": b\"fake_audio_data\",\n                \"audio_format\": \"wav\"\n            }\n        }\n        \n        with patch.object(coordinator, 'service_manager', mock_service_clients.return_value):\n            results = await coordinator.start_diagnosis_process(\n                user_id, session_id, diagnosis_data\n            )\n        \n        assert len(results)==2\n        assert all(isinstance(result, DiagnosisResult) for result in results)\n        assert all(result.user_id==user_id for result in results)\n        assert all(result.session_id==session_id for result in results)\n    \n    @pytest.mark.asyncio\n    async def test_coordinate_five_diagnosis_success(self, coordinator, mock_service_clients):\n        \"\"\"测试五诊协调成功场景\"\"\"\n        user_id = \"test_user_123\"\n        session_id = \"test_session_123\"\n        \n        # 准备完整的五诊数据\n        diagnosis_data = {\n            DiagnosisType.LOOKING: {\"image_data\": b\"tongue_image\"},\n            DiagnosisType.LISTENING: {\"audio_data\": b\"voice_audio\"},\n            DiagnosisType.INQUIRY: {\"conversation_data\": {\"symptoms\": [\"头痛\", \"失眠\"]}},\n            DiagnosisType.PALPATION: {\"pulse_data\": {\"rate\": 72, \"rhythm\": \"regular\"}},\n            DiagnosisType.CALCULATION: {\"biomarker_data\": {\"glucose\": 5.5}}\n        }\n        \n        with patch.object(coordinator, 'service_manager', mock_service_clients.return_value):\n            coordination_result = await coordinator.coordinate_five_diagnosis(\n                user_id, session_id, diagnosis_data\n            )\n        \n        assert coordination_result is not None\n        assert \"individual_results\" in coordination_result\n        assert \"fusion_result\" in coordination_result\n        assert \"confidence_scores\" in coordination_result\n        assert len(coordination_result[\"individual_results\"])==5\n    \n    @pytest.mark.asyncio\n    async def test_coordinate_five_diagnosis_partial_data(self, coordinator, mock_service_clients):\n        \"\"\"测试部分诊断数据的协调\"\"\"\n        user_id = \"test_user_123\"\n        session_id = \"test_session_123\"\n        \n        # 只提供部分诊断数据\n        diagnosis_data = {\n            DiagnosisType.LOOKING: {\"image_data\": b\"tongue_image\"},\n            DiagnosisType.INQUIRY: {\"conversation_data\": {\"symptoms\": [\"头痛\"]}}\n        }\n        \n        with patch.object(coordinator, 'service_manager', mock_service_clients.return_value):\n            coordination_result = await coordinator.coordinate_five_diagnosis(\n                user_id, session_id, diagnosis_data\n            )\n        \n        assert coordination_result is not None\n        assert len(coordination_result[\"individual_results\"])==2\n        # 部分数据的置信度应该较低\n        assert coordination_result[\"fusion_result\"][\"overall_confidence\"] < 0.8\n    \n    @pytest.mark.asyncio\n    async def test_service_unavailable_handling(self, coordinator):\n        \"\"\"测试服务不可用的处理\"\"\"\n        user_id = \"test_user_123\"\n        session_id = \"test_session_123\"\n        \n        diagnosis_data = {\n            DiagnosisType.LOOKING: {\"image_data\": b\"fake_image_data\"}\n        }\n        \n        # 模拟服务不可用\n        with patch.object(coordinator, 'service_manager') as mock_manager:\n            mock_manager.get_client.return_value = None\n            \n            with pytest.raises(ServiceUnavailableError):\n                await coordinator.start_diagnosis_process(\n                    user_id, session_id, diagnosis_data\n                )\n    \n    @pytest.mark.asyncio\n    async def test_data_fusion_algorithm(self, coordinator):\n        \"\"\"测试数据融合算法\"\"\"\n        # 准备模拟的诊断结果\n        results = [\n            DiagnosisResult(\n                session_id=\"test_session\",\n                user_id=\"test_user\",\n                diagnosis_type=DiagnosisType.LOOKING,\n                status=DiagnosisStatus.COMPLETED,\n                confidence=0.8,\n                features={\"tongue_color\": \"红\", \"tongue_coating\": \"厚腻\"},\n                raw_data={}\n            ),\n            DiagnosisResult(\n                session_id=\"test_session\",\n                user_id=\"test_user\",\n                diagnosis_type=DiagnosisType.INQUIRY,\n                status=DiagnosisStatus.COMPLETED,\n                confidence=0.9,\n                features={\"symptoms\": [\"头痛\", \"失眠\"], \"duration\": \"1周\"},\n                raw_data={}\n            )\n        ]\n        \n        fusion_result = await coordinator._fuse_diagnosis_results(results)\n        \n        assert \"overall_confidence\" in fusion_result\n        assert \"combined_features\" in fusion_result\n        assert \"syndrome_indicators\" in fusion_result\n        assert fusion_result[\"overall_confidence\"] > 0\n    \n    @pytest.mark.asyncio\n    async def test_confidence_calculation(self, coordinator):\n        \"\"\"测试置信度计算\"\"\"\n        # 测试不同置信度的结果\n        high_confidence_results = [\n            Mock(confidence=0.9, status=DiagnosisStatus.COMPLETED),\n            Mock(confidence=0.8, status=DiagnosisStatus.COMPLETED),\n            Mock(confidence=0.85, status=DiagnosisStatus.COMPLETED)\n        ]\n        \n        low_confidence_results = [\n            Mock(confidence=0.3, status=DiagnosisStatus.COMPLETED),\n            Mock(confidence=0.4, status=DiagnosisStatus.COMPLETED)\n        ]\n        \n        mixed_results = [\n            Mock(confidence=0.9, status=DiagnosisStatus.COMPLETED),\n            Mock(confidence=0.2, status=DiagnosisStatus.FAILED)\n        ]\n        \n        high_conf = coordinator._calculate_overall_confidence(high_confidence_results)\n        low_conf = coordinator._calculate_overall_confidence(low_confidence_results)\n        mixed_conf = coordinator._calculate_overall_confidence(mixed_results)\n        \n        assert high_conf > low_conf\n        assert high_conf > mixed_conf\n        assert 0<=low_conf<=1\n        assert 0<=mixed_conf<=1\n    \n    @pytest.mark.asyncio\n    async def test_session_timeout_handling(self, coordinator):\n        \"\"\"测试会话超时处理\"\"\"\n        user_id = \"test_user_123\"\n        \n        # 创建会话\n        session = await coordinator.create_diagnosis_session(user_id)\n        \n        # 模拟会话超时\n        with patch('xiaoai.core.five_diagnosis_coordinator.datetime') as mock_datetime:\n            # 设置当前时间为会话创建时间 + 超时时间 + 1分钟\n            timeout_time = session.created_at.timestamp() + coordinator.session_timeout + 60\n            mock_datetime.now.return_value = datetime.fromtimestamp(timeout_time, tz=timezone.utc)\n            \n            # 检查会话是否超时\n            is_expired = coordinator._is_session_expired(session)\n            assert is_expired is True\n    \n    @pytest.mark.asyncio\n    async def test_error_handling_in_diagnosis(self, coordinator, mock_service_clients):\n        \"\"\"测试诊断过程中的错误处理\"\"\"\n        user_id = \"test_user_123\"\n        session_id = \"test_session_123\"\n        \n        diagnosis_data = {\n            DiagnosisType.LOOKING: {\"image_data\": b\"corrupted_data\"}\n        }\n        \n        # 模拟服务调用异常\n        with patch.object(coordinator, 'service_manager', mock_service_clients.return_value):\n            mock_service_clients.return_value.get_client.return_value.analyze.side_effect = Exception(\"Service error\")\n            \n            results = await coordinator.start_diagnosis_process(\n                user_id, session_id, diagnosis_data\n            )\n            \n            # 应该返回失败的结果而不是抛出异常\n            assert len(results)==1\n            assert results[0].status==DiagnosisStatus.FAILED\n            assert results[0].error_message is not None\n    \n    @pytest.mark.asyncio\n    async def test_concurrent_diagnosis_requests(self, coordinator, mock_service_clients):\n        \"\"\"测试并发诊断请求\"\"\"\n        user_id = \"test_user_123\"\n        \n        # 创建多个并发诊断请求\n        tasks = []\n        for i in range(5):\n            session_id = f\"test_session_{i}\"\n            diagnosis_data = {\n                DiagnosisType.LOOKING: {\"image_data\": f\"image_data_{i}\".encode()}\n            }\n            \n            with patch.object(coordinator, 'service_manager', mock_service_clients.return_value):\n                task = coordinator.start_diagnosis_process(\n                    user_id, session_id, diagnosis_data\n                )\n                tasks.append(task)\n        \n        # 等待所有任务完成\n        results_list = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # 检查所有请求都成功处理\n        assert len(results_list)==5\n        for results in results_list:\n            assert not isinstance(results, Exception)\n            assert len(results)==1\n    \n    def test_diagnosis_type_enum(self):\n        \"\"\"测试诊断类型枚举\"\"\"\n        assert DiagnosisType.LOOKING.value==\"looking\"\n        assert DiagnosisType.LISTENING.value==\"listening\"\n        assert DiagnosisType.INQUIRY.value==\"inquiry\"\n        assert DiagnosisType.PALPATION.value==\"palpation\"\n        assert DiagnosisType.CALCULATION.value==\"calculation\"\n    \n    def test_diagnosis_status_enum(self):\n        \"\"\"测试诊断状态枚举\"\"\"\n        assert DiagnosisStatus.PENDING.value==\"pending\"\n        assert DiagnosisStatus.IN_PROGRESS.value==\"in_progress\"\n        assert DiagnosisStatus.COMPLETED.value==\"completed\"\n        assert DiagnosisStatus.FAILED.value==\"failed\"\n    \n    def test_session_status_enum(self):\n        \"\"\"测试会话状态枚举\"\"\"\n        assert SessionStatus.ACTIVE.value==\"active\"\n        assert SessionStatus.COMPLETED.value==\"completed\"\n        assert SessionStatus.EXPIRED.value==\"expired\"\n        assert SessionStatus.CANCELLED.value==\"cancelled\"\n    \n    @pytest.mark.asyncio\n    async def test_diagnosis_result_validation(self, coordinator):\n        \"\"\"测试诊断结果验证\"\"\"\n        # 测试有效的诊断结果\n        valid_result = DiagnosisResult(\n            session_id=\"test_session\",\n            user_id=\"test_user\",\n            diagnosis_type=DiagnosisType.LOOKING,\n            status=DiagnosisStatus.COMPLETED,\n            confidence=0.8,\n            features={\"valid\": \"data\"},\n            raw_data={}\n        )\n        \n        is_valid = coordinator._validate_diagnosis_result(valid_result)\n        assert is_valid is True\n        \n        # 测试无效的诊断结果（置信度超出范围）\n        invalid_result = DiagnosisResult(\n            session_id=\"test_session\",\n            user_id=\"test_user\",\n            diagnosis_type=DiagnosisType.LOOKING,\n            status=DiagnosisStatus.COMPLETED,\n            confidence=1.5,  # 无效的置信度\n            features={},\n            raw_data={}\n        )\n        \n        is_valid = coordinator._validate_diagnosis_result(invalid_result)\n        assert is_valid is False\n    \n    @pytest.mark.asyncio\n    async def test_session_cleanup(self, coordinator):\n        \"\"\"测试会话清理\"\"\"\n        user_id = \"test_user_123\"\n        \n        # 创建多个会话\n        sessions = []\n        for i in range(3):\n            session = await coordinator.create_diagnosis_session(user_id)\n            sessions.append(session)\n        \n        # 验证会话已创建\n        assert len(coordinator.active_sessions)==3\n        \n        # 执行会话清理\n        await coordinator._cleanup_expired_sessions()\n        \n        # 由于会话刚创建，应该还没有过期\n        assert len(coordinator.active_sessions)==3\n        \n        # 模拟会话过期并清理\n        for session in sessions:\n            session.status = SessionStatus.EXPIRED\n        \n        await coordinator._cleanup_expired_sessions()\n        \n        # 过期会话应该被清理\n        active_count = sum(1 for s in coordinator.active_sessions.values() \n                          if s.status==SessionStatus.ACTIVE)\n        assert active_count==0"